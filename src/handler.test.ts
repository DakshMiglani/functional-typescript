import Ajv from 'ajv'
import test from 'ava'
import * as fs from 'fs-extra'
import getPort from 'get-port'
// import * as globby from 'globby'
import got from 'got'
import jsf from 'json-schema-faker'
import * as path from 'path'
import pify from 'pify'
import * as qs from 'qs'
import seedrandom from 'seedrandom'
import * as tempy from 'tempy'
import * as FTS from '.'

const fixtures = ['./fixtures/power.ts'] // globby.sync('./fixtures/**/*.ts')
const ajv = new Ajv({ useDefaults: true, coerceTypes: true })

jsf.option({
  alwaysFakeOptionals: true,
  // make values generated by json-schema-faker deterministic
  random: seedrandom('NzYxNDdlNjgxYzliN2FkNjFmYjBlMTI5')
})

for (const fixture of fixtures) {
  const { name } = path.parse(fixture)

  test(name, async (t) => {
    const outDir = tempy.directory()
    const definition = await FTS.generateDefinition(fixture, {
      compilerOptions: {
        outDir
      },
      emit: true
    })
    t.truthy(definition)

    const jsFilePath = path.join(outDir, `${name}.js`)
    const handler = FTS.createHttpHandler(definition, jsFilePath)
    t.is(typeof handler, 'function')

    const port = await getPort()
    const server = await FTS.createHttpServer(handler, port)

    const params = await jsf.resolve(definition.params.schema)
    const query = qs.stringify(params)

    console.log({ name, params, query, port })
    const response = await got(`http://localhost:${port}`, {
      json: true,
      query
    })
    console.log({
      body: response.body,
      statusCode: response.statusCode
    })
    t.is(response.statusCode, 200)

    const validateReturns = ajv.compile(definition.returns.schema)
    validateReturns(response.body)
    t.is(validateReturns.errors, null)

    // TODO: response.body may be false, null, undefined, '', or NaN

    // TODO: invoke original TS function with params and ensure same result!
    // TODO: snapshot statusCode, statusMessage, and body

    await pify(server.close.bind(server))()
    await fs.remove(outDir)
  })
}
